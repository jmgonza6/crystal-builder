\hypertarget{class_parser}{}\section{Parser Class Reference}
\label{class_parser}\index{Parser@{Parser}}


\subsection{Detailed Description}
\subsection*{{\bfseries Purpose\+:} }

\begin{DoxyVerb}/*****************************************************************************\
/  Class to process different types of strings, mainly conversion and search  \
/  functions.                                                                 \
/                                                                             \
/*****************************************************************************\
\end{DoxyVerb}


\begin{DoxyAuthor}{Author}
Joseph M. Gonzalez
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
0.\+1
\end{DoxyVersion}
\begin{DoxyDate}{Date}
Sep 13, 2015 19\+:16\+:20
\end{DoxyDate}
{\bfseries Contact} ~\newline
 \href{mailto:jmgonza6@mail.usf.edu}{\tt jmgonza6@mail.\+usf.\+edu} \subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{class_parser_a12234f6cd36b61af4b50c94a179422c1}{Parser} ()
\item 
\hyperlink{class_parser_a3e658b5917a93a3ef648050d060e3a93}{$\sim$\+Parser} ()
\item 
{\footnotesize template$<$typename ret\+Val $>$ }\\ret\+Val \hyperlink{class_parser_a7fd979d81465947482756e449939cc86}{str2num} (const std\+::string \&numstr)
\begin{DoxyCompactList}\small\item\em Template to convert a {\bfseries {\ttfamily std\+::string}} type to a numeric type. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{class_parser_ac9491abb25649667d76cce465f5e83e3}{str2char} (std\+::string str)
\begin{DoxyCompactList}\small\item\em Converts a {\bfseries {\ttfamily std\+::string}} type to {\bfseries {\ttfamily char} $\ast$} \end{DoxyCompactList}\item 
int \hyperlink{class_parser_af09b8e0fbda4e0c5a4d54aa8bebb0af4}{match\+\_\+phrase} (F\+I\+L\+E $\ast$fptr, char $\ast$phrase, char $\ast$line)
\begin{DoxyCompactList}\small\item\em Search for a specific pattern in a text file. \end{DoxyCompactList}\item 
int \hyperlink{class_parser_a70a6ed79f6a59e99d232c62002b0f1d0}{count\+\_\+words} (std\+::string list)
\begin{DoxyCompactList}\small\item\em Count the number of words in a string. \end{DoxyCompactList}\item 
int \hyperlink{class_parser_aa2f8f6e7b9906302de1d36b30bc9d969}{find\+\_\+rec} (std\+::string list, std\+::string pattern, int \&index)
\begin{DoxyCompactList}\small\item\em Find a word in a list of words separated by whitespace. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::string $>$ \hyperlink{class_parser_a9b2186ca0eff614eac41bc485ba06dd1}{split\+\_\+list} (std\+::string list, char delim)
\begin{DoxyCompactList}\small\item\em Parse a string of words based on a delimeter. \end{DoxyCompactList}\item 
char $\ast$ \hyperlink{class_parser_af5557acf700265e52c44d4501b90dbc3}{str\+\_\+manip} (char $\ast$str, char $\ast$insert, char delim)
\begin{DoxyCompactList}\small\item\em Insert a word based on a delimeter. \end{DoxyCompactList}\item 
int \hyperlink{class_parser_abf72a3b9424e25b2768a16bce23584c2}{get\+\_\+substrings} (std\+::string list, char d1, char d2, std\+::vector$<$ std\+::string $>$ \&keys, std\+::vector$<$ std\+::string $>$ \&vals)
\begin{DoxyCompactList}\small\item\em Parse a string of words based on two delimeters. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{class_parser_a12234f6cd36b61af4b50c94a179422c1}{}\index{Parser@{Parser}!Parser@{Parser}}
\index{Parser@{Parser}!Parser@{Parser}}
\subsubsection[{Parser}]{\setlength{\rightskip}{0pt plus 5cm}Parser\+::\+Parser (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_parser_a12234f6cd36b61af4b50c94a179422c1}
\hypertarget{class_parser_a3e658b5917a93a3ef648050d060e3a93}{}\index{Parser@{Parser}!````~Parser@{$\sim$\+Parser}}
\index{````~Parser@{$\sim$\+Parser}!Parser@{Parser}}
\subsubsection[{$\sim$\+Parser}]{\setlength{\rightskip}{0pt plus 5cm}Parser\+::$\sim$\+Parser (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{class_parser_a3e658b5917a93a3ef648050d060e3a93}


\subsection{Member Function Documentation}
\hypertarget{class_parser_a70a6ed79f6a59e99d232c62002b0f1d0}{}\index{Parser@{Parser}!count\+\_\+words@{count\+\_\+words}}
\index{count\+\_\+words@{count\+\_\+words}!Parser@{Parser}}
\subsubsection[{count\+\_\+words}]{\setlength{\rightskip}{0pt plus 5cm}int Parser\+::count\+\_\+words (
\begin{DoxyParamCaption}
\item[{std\+::string}]{list}
\end{DoxyParamCaption}
)}\label{class_parser_a70a6ed79f6a59e99d232c62002b0f1d0}


Count the number of words in a string. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em list} & -\/ strings to be parsed based on whitespace \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of words 
\end{DoxyReturn}
\hypertarget{class_parser_aa2f8f6e7b9906302de1d36b30bc9d969}{}\index{Parser@{Parser}!find\+\_\+rec@{find\+\_\+rec}}
\index{find\+\_\+rec@{find\+\_\+rec}!Parser@{Parser}}
\subsubsection[{find\+\_\+rec}]{\setlength{\rightskip}{0pt plus 5cm}int Parser\+::find\+\_\+rec (
\begin{DoxyParamCaption}
\item[{std\+::string}]{list, }
\item[{std\+::string}]{pattern, }
\item[{int \&}]{index}
\end{DoxyParamCaption}
)}\label{class_parser_aa2f8f6e7b9906302de1d36b30bc9d969}


Find a word in a list of words separated by whitespace. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em list} & -\/ string of words to be parsed \\
\hline
\mbox{\tt in}  & {\em pattern} & -\/ pattern to match in {\ttfamily list} \\
\hline
\mbox{\tt out}  & {\em index} & -\/ strings to be parsed based on whitespace \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries {\ttfamily 1}} if successful, {\bfseries {\ttfamily 0}} otherwise. 
\end{DoxyReturn}
\hypertarget{class_parser_abf72a3b9424e25b2768a16bce23584c2}{}\index{Parser@{Parser}!get\+\_\+substrings@{get\+\_\+substrings}}
\index{get\+\_\+substrings@{get\+\_\+substrings}!Parser@{Parser}}
\subsubsection[{get\+\_\+substrings}]{\setlength{\rightskip}{0pt plus 5cm}int Parser\+::get\+\_\+substrings (
\begin{DoxyParamCaption}
\item[{std\+::string}]{list, }
\item[{char}]{d1, }
\item[{char}]{d2, }
\item[{std\+::vector$<$ std\+::string $>$ \&}]{keys, }
\item[{std\+::vector$<$ std\+::string $>$ \&}]{vals}
\end{DoxyParamCaption}
)}\label{class_parser_abf72a3b9424e25b2768a16bce23584c2}


Parse a string of words based on two delimeters. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em list} & -\/ string of words to be parsed \\
\hline
\mbox{\tt in}  & {\em d1} & -\/ fisrt delimeter to use for splitting \\
\hline
\mbox{\tt in}  & {\em d2} & -\/ second delimeter to use for splitting the result of {\ttfamily d1} \\
\hline
\mbox{\tt in}  & {\em keys} & -\/ keywords to search for in {\ttfamily list} \\
\hline
\mbox{\tt in}  & {\em vals} & -\/ values associated with {\ttfamily keys} in {\ttfamily list} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries {\ttfamily 1}} if successful, {\bfseries {\ttfamily 0}} otherwise. 
\end{DoxyReturn}
\hypertarget{class_parser_af09b8e0fbda4e0c5a4d54aa8bebb0af4}{}\index{Parser@{Parser}!match\+\_\+phrase@{match\+\_\+phrase}}
\index{match\+\_\+phrase@{match\+\_\+phrase}!Parser@{Parser}}
\subsubsection[{match\+\_\+phrase}]{\setlength{\rightskip}{0pt plus 5cm}int Parser\+::match\+\_\+phrase (
\begin{DoxyParamCaption}
\item[{F\+I\+L\+E $\ast$}]{fptr, }
\item[{char $\ast$}]{phrase, }
\item[{char $\ast$}]{line}
\end{DoxyParamCaption}
)}\label{class_parser_af09b8e0fbda4e0c5a4d54aa8bebb0af4}


Search for a specific pattern in a text file. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em fptr} & -\/ Pointer to the file \\
\hline
\mbox{\tt in}  & {\em phrase} & -\/ Specific pattern to match \\
\hline
\mbox{\tt out}  & {\em line} & -\/ Entire line containing the pattern, simillar to {\ttfamily grep} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries {\ttfamily 1}} if successful, {\bfseries {\ttfamily 0}} otherwise 
\end{DoxyReturn}
\hypertarget{class_parser_a9b2186ca0eff614eac41bc485ba06dd1}{}\index{Parser@{Parser}!split\+\_\+list@{split\+\_\+list}}
\index{split\+\_\+list@{split\+\_\+list}!Parser@{Parser}}
\subsubsection[{split\+\_\+list}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$std\+::string$>$ Parser\+::split\+\_\+list (
\begin{DoxyParamCaption}
\item[{std\+::string}]{list, }
\item[{char}]{delim}
\end{DoxyParamCaption}
)}\label{class_parser_a9b2186ca0eff614eac41bc485ba06dd1}


Parse a string of words based on a delimeter. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em list} & -\/ string of words to be parsed \\
\hline
\mbox{\tt in}  & {\em delim} & -\/ delimeter to use for splitting \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a {\bfseries {\ttfamily std\+::vector$<$std\+::string$>$}} type containing the words found in {\ttfamily list} 
\end{DoxyReturn}
\hypertarget{class_parser_ac9491abb25649667d76cce465f5e83e3}{}\index{Parser@{Parser}!str2char@{str2char}}
\index{str2char@{str2char}!Parser@{Parser}}
\subsubsection[{str2char}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ Parser\+::str2char (
\begin{DoxyParamCaption}
\item[{std\+::string}]{str}
\end{DoxyParamCaption}
)}\label{class_parser_ac9491abb25649667d76cce465f5e83e3}


Converts a {\bfseries {\ttfamily std\+::string}} type to {\bfseries {\ttfamily char} $\ast$} 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & -\/ the string to be converted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\bfseries {\ttfamily char} $\ast$} if successfull, {\bfseries {\ttfamily N\+U\+L\+L}} otherwise 
\end{DoxyReturn}
\hypertarget{class_parser_a7fd979d81465947482756e449939cc86}{}\index{Parser@{Parser}!str2num@{str2num}}
\index{str2num@{str2num}!Parser@{Parser}}
\subsubsection[{str2num}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename ret\+Val $>$ ret\+Val Parser\+::str2num (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{numstr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{class_parser_a7fd979d81465947482756e449939cc86}


Template to convert a {\bfseries {\ttfamily std\+::string}} type to a numeric type. 


\begin{DoxyTemplParams}{Template Parameters}
{\em numstr} & -\/ Address of the string to convert \\
\hline
\end{DoxyTemplParams}
\begin{DoxyReturn}{Returns}
a number of type {\bfseries {\ttfamily ret\+Val}} 
\end{DoxyReturn}
\hypertarget{class_parser_af5557acf700265e52c44d4501b90dbc3}{}\index{Parser@{Parser}!str\+\_\+manip@{str\+\_\+manip}}
\index{str\+\_\+manip@{str\+\_\+manip}!Parser@{Parser}}
\subsubsection[{str\+\_\+manip}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ Parser\+::str\+\_\+manip (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{str, }
\item[{char $\ast$}]{insert, }
\item[{char}]{delim}
\end{DoxyParamCaption}
)}\label{class_parser_af5557acf700265e52c44d4501b90dbc3}


Insert a word based on a delimeter. 


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em str} & -\/ string to have a word inserted \\
\hline
\mbox{\tt in}  & {\em insert} & -\/ word to insert in {\ttfamily str} \\
\hline
\mbox{\tt in}  & {\em delim} & -\/ delimeter to use for locating the end \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a {\bfseries {\ttfamily char$\ast$}} type containing compound word 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
src/util/\hyperlink{common_8h}{common.\+h}\end{DoxyCompactItemize}
